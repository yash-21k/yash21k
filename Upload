class Solution {

    static long answer;

    public int maxscore(int nodeval[], int[][] edges) {

        int n = nodeval.length;

        // ----- build adjacency list using arrays -----
        int[] degree = new int[n];

        for (int[] e : edges) {
            degree[e[0]-1]++;
            degree[e[1]-1]++;
        }

        int[][] adj = new int[n][];
        for (int i = 0; i < n; i++)
            adj[i] = new int[degree[i]];

        int[] idx = new int[n];

        for (int[] e : edges) {
            int u = e[0]-1, v = e[1]-1;

            adj[u][idx[u]++] = v;
            adj[v][idx[v]++] = u;
        }

        answer = Long.MIN_VALUE;

        dfs(0, -1, nodeval, adj);

        return (int)answer;
    }

    // returns {maxDown, minDown}
    static long[] dfs(int node, int parent, int[] val, int[][] adj) {

        boolean isLeaf = true;

        long maxDown = Long.MIN_VALUE;
        long minDown = Long.MAX_VALUE;

        long[] childMax = new long[adj[node].length];
        long[] childMin = new long[adj[node].length];

        int count = 0;

        for (int next : adj[node]) {

            if (next == parent) continue;

            isLeaf = false;

            long[] child = dfs(next, node, val, adj);

            long a = child[0] * val[node];
            long b = child[1] * val[node];

            childMax[count] = Math.max(a, b);
            childMin[count] = Math.min(a, b);

            maxDown = Math.max(maxDown, childMax[count]);
            minDown = Math.min(minDown, childMin[count]);

            count++;
        }

        // leaf
        if (isLeaf) {
            return new long[]{val[node], val[node]};
        }

        // combine children pairs for leaf-to-leaf
        for (int i = 0; i < count; i++) {
            for (int j = i + 1; j < count; j++) {

                long[] cand = {
                        (long)val[node] * childMax[i] * childMax[j],
                        (long)val[node] * childMax[i] * childMin[j],
                        (long)val[node] * childMin[i] * childMax[j],
                        (long)val[node] * childMin[i] * childMin[j]
                };

                for (long c : cand)
                    answer = Math.max(answer, c);
            }
        }

        return new long[]{maxDown, minDown};
    }

    // ---- MAIN FUNCTION WITH EXAMPLE INPUT ----
    public static void main(String[] args) {

        Solution sol = new Solution();

        // Example:
        // Node values:
        // 1 -> -1
        // 2 -> 2
        // 3 -> 3
        // 4 -> 2
        int[] nodeval = {-1, 2, 3, 2};

        // Edges:
        // 1-2, 1-3, 3-4
        int[][] edges = {
                {1, 2},
                {1, 3},
                {3, 4}
        };

        int result = sol.maxscore(nodeval, edges);

        System.out.println(result);  // Expected output: -12
    }
}